// O(1) < O(log(n)) < O(n) < O(nlog(n)) < O(n^2) < O(n^3) < O(b^n), b > 1 < O(n!)

// 1. Set bit
num |= 1UL << pos;

// 2. Clear bit
num &= ~(1UL << pos);
num &= !(1 << pos);  // For Rust

// 3. Toggle bit
num ^= 1UL << pos;

// 4. Check bit
bit = (num >> pos) & 1UL;

// 5. Change nth bit to x:
num ^= (-x ^ num) & (1 << n);

// 6. Extract last bit
bit = num & -num;
let bit = num & num.wrappint_neg();  // For Rust
or
bit = num & ~(num - 1);
let bit = num & !(num - 1);  // For Rust

//Note:   -num is equal to ~(num - 1)

// 7. Remove last bit
num &= (num - 1)

// 8. Find posiiton of rightmost set(1) bit:
int pos = log2(num & -num);
let pos = (num & num.wrapping_neg()).trailing_zeros() as usize;  // For Rust

// 9. Swap bits
int bit1 = (num >> pos1) & 1UL;
int bit2 = (num >> pos2) & 1UL;
int x = (bit1 ^ bit2);
num ^= ((x << pos1) | (x << pos2))

// 10. reverse bits
int res = 0;
for (int i = 0; i < 32; i++, n >>= 1) {
    res <<= 1;
    res |= n & 1;
}

// 11. chop bits
int32_t res;
int32_t mask = -1;   //. 1111 1111
mask = ~(mask << len);    // 0000. 0011.  ex len = 2
num >>= pos;
res = num & mask;
// or
res = (((1 << len) - 1) & (n >> (pos - 1)));


#define MAX(x, y) x ^ ((x^y) & -(x < y))
#define MIN(x, y) y ^ ((x^y) & -(x < y))


5:   0000 0101
~5:  1111 1010
5-1: 0000 0100
-5:  1111 1011

4:   0000 0100
~4:  1111 1011
4-1: 0000 0011
-4:  1111 1100


auto maxIt = max_element(mp.begin(), mp.end(), [](const auto& l, const auto& r) -> bool { return l.second < r.second; });
auto minIt = min_element(mp.begin(), mp.end(), [](const auto& l, const auto& r) -> bool { return l.second < r.second; });

// Convert lower case to upper case
str[i] -= 32;
or
str[i] += ('Z' - 'z');

// Convert upper case to lower case
str[i] += 32;
or
str[i] -= ('Z' - 'z');

// Convert char to integer
int n = str[i] - '0';   // '5' -> 5

// Get the coresponding index of char
// æœ€å¸¸ç”¨åœ¨ã€Œå­—å…ƒ â†’ 0-based æ•´æ•¸ç´¢å¼•ã€çš„è½‰æ›ï¼Œç‰¹åˆ¥æ˜¯è™•ç† å°å¯«è‹±æ–‡å­—æ¯ 'a' ~ 'z' çš„æƒ…å¢ƒã€‚
int idx = str[i] - 'a';

/*
int x = str[i] - 'a';   // è‹¥ str[i] ä¸æ˜¯ 'a'~'z' â†’ å‡ºéŒ¯
âœ… æ­£ç¢ºå¯«æ³•
c
Copy code
if (str[i] >= 'a' && str[i] <= 'z') {
    int x = str[i] - 'a';
}*/

=======================================================================
#include <iostream>
#include <vector>

using namespace std;

int UpperBound(vector<int> nums, int key) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= key) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

int LowerBound(vector<int> nums, int key) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < key) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left - 1;
}

int main(int argc, char** argv) {
    vector<int> nums = {1, 2, 3, 4, 5, 6};
    
    cout << "Lower bound: " << nums[LowerBound(nums, 4)] << endl;
    
    cout << "Upper bound: " << nums[UpperBound(nums, 4)] << endl;
    return 0;
}
=======================================================================
#include <array>

array<pair<int, int>, 4> dirs{pair<int, int>{0, -1}, {0, 1}, {-1, 0}, {1, 0}};

for (const auto [dx, dy] : dirs) {
    int x = r + dx, y = c + dy;
}
=======================================================================

Sliding Windowï¼ˆPermutation / Anagramï¼‰ã€Œå¯èƒŒæ¨¡æ¿ã€
âœ… å›ºå®šé•·åº¦ + å­—å…ƒé »ç‡ï¼ˆ26 lettersï¼‰
bool slidingWindow(string s1, string s2) {
    if (s1.size() > s2.size()) return false;

    vector<int> cnt(26, 0);
    for (char c : s1) cnt[c - 'a']++;

    int left = 0, right = 0;
    int need = s1.size();

    while (right < s2.size()) {
        // 1ï¸âƒ£ æ“´å¼µå³é‚Š
        if (cnt[s2[right] - 'a'] > 0)
            need--;
        cnt[s2[right] - 'a']--;
        right++;

        // 2ï¸âƒ£ å‘½ä¸­æ¢ä»¶
        if (need == 0) return true;

        // 3ï¸âƒ£ ç¶­æŒå›ºå®šé•·åº¦ï¼ˆshrinkï¼‰
        if (right - left == s1.size()) {
            if (cnt[s2[left] - 'a'] >= 0)
                need++;
            cnt[s2[left] - 'a']++;
            left++;
        }
    }
    return false;
}

äºŒã€å£è¨£ç‰ˆï¼ˆé¢è©¦æ™‚è…¦ä¸­é»˜å¿µï¼‰
ğŸ§  å››å¥è©±èƒŒèµ·ä¾†

1ï¸âƒ£ å³é‚Šé€²ä¾†ï¼Œå…ˆæ‰£è¡¨
2ï¸âƒ£ æ‰£åˆ°éœ€è¦çš„ï¼Œneed--
3ï¸âƒ£ è¦–çª—å¤ªå¤§ï¼Œå·¦é‚Šå‡ºå»
4ï¸âƒ£ å‡ºçš„æ˜¯éœ€è¦çš„ï¼Œneed++
======================================================================

C++ ä¸­çš„ Min Heapï¼ˆé¢è©¦ä¸€å®šæœƒå¯«ï¼‰
C++ é è¨­æ˜¯ max heapï¼Œè¦é€™æ¨£å¯«ï¼š

/*
Min Heap æ˜¯ä¸€å€‹ å®Œå…¨äºŒå‰æ¨¹ï¼Œæ¯å€‹ç¯€é»éƒ½ â‰¤ å®ƒçš„å­ç¯€é»
ğŸ‘‰ æ‰€ä»¥ æ ¹ç¯€é»æ°¸é æ˜¯æœ€å°å€¼

ç‰¹æ€§ï¼š

å®Œå…¨äºŒå‰æ¨¹ï¼ˆtree å®Œå…¨å¡«æ»¿ï¼Œæœ€å¾Œä¸€å±¤å¾å·¦åˆ°å³å¡«ï¼‰

çˆ¶ç¯€é» â‰¤ å·¦å³å­ç¯€é»

æ’å…¥ / åˆªé™¤æœ€å°å€¼ = O(log n)

      1
     / \
    2   5
   /
  3
*/

priority_queue<int, vector<int>, greater<int>> minHeap;  // Min heap
// NOTE:  priority_queue<int> maxHeap;  // Max heap

minHeap.push(3);
minHeap.push(1);
minHeap.push(2);

cout << minHeap.top();  // 1
------------------------------------------------------------------------
// min heap
auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };

priority_queue<ListNode*, vector<ListNode*> decltype(cmp)> minHeap(cmp);
