Dynamic programming

完全背包（Unbounded Knapsack） 是指：
👉 每一個物品可以被選擇「無限次」的背包問題

題型	            loop (內層）
0/1 背包	        倒著
完全背包	        正著


和 0/1 背包的關鍵差異（超重要）
類型	          每個物品可用次數	        常見例子
0/1 背包	      只能 0 或 1 次	        面試、選課
完全背包	      無限次	                硬幣、切木頭


🔹 轉移方向差異（重點🔥）
✅ 完全背包（正著 loop）
for (coin : coins)
    for (x = coin; x <= amount; x++)
        dp[x] = min(dp[x], dp[x - coin] + 1);


為什麼正著？

因為 dp[x - coin] 可以是「這一輪剛更新過的」
👉 代表同一個物品能用多次

❌ 0/1 背包（倒著 loop）
for (item : items)
    for (x = capacity; x >= item; x--)
        dp[x] = max(dp[x], dp[x - item] + value);


為什麼倒著？

防止同一個物品在同一輪被用兩次

一句超好記的口訣（面試救命）

「能不能重複拿 → 決定內層正 or 倒」

能不能重複	loop 方向
❌ 不行（0/1）	倒著
✅ 可以（完全）	正著



和「最少硬幣數」那題差在哪？
題型	dp 定義	轉移
最少硬幣	min 次數	min(dp[x], dp[x-c]+1)
組合數	方案數	dp[x] += dp[x-c]

但兩個 都是完全背包、正向 loop。

面試口訣（直接背）

算組合 → coin 在外
算排列 → amount 在外
能重複 → 正著 loop
