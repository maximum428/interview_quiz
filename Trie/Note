1ï¸âƒ£ é¢è©¦ä¸€å¥è©±è¨­è¨ˆæ€è·¯ï¼ˆå¿…èƒŒï¼‰

ä½¿ç”¨ Trie å„²å­˜å­—å…¸ï¼Œ
æœå°‹æ™‚é‡åˆ°æ™®é€šå­—å…ƒæ²¿å–®ä¸€è·¯å¾‘èµ°ï¼Œ
é‡åˆ° . å‰‡ DFS å˜—è©¦æ‰€æœ‰å­ç¯€é»ï¼Œ
ä»»ä¸€åˆ†æ”¯æˆåŠŸå³å›å‚³ trueã€‚

2ï¸âƒ£ Trie é€šç”¨çµæ§‹æ¨¡æ¿ï¼ˆå¯å¥— 80% é¡Œç›®ï¼‰
struct TrieNode {
    bool isWord;
    TrieNode* child[26];

    TrieNode() : isWord(false) {
        memset(child, 0, sizeof(child));
    }
};


ğŸ“Œ é¢è©¦å®˜çœ‹åˆ°é€™å€‹çµæ§‹å°±çŸ¥é“ä½ æ˜¯ã€Œæ¨™æº–è§£ã€

3ï¸âƒ£ wildcard æœå°‹ DFS æ¨¡æ¿ï¼ˆæ ¸å¿ƒå¿…èƒŒï¼‰
bool dfs(const string& word, int pos, TrieNode* node) {
    if (!node) return false;

    if (pos == word.size())
        return node->isWord;

    char c = word[pos];
    if (c != '.') {
        return dfs(word, pos + 1, node->child[c - 'a']);
    } else {
        for (int i = 0; i < 26; i++) {
            if (node->child[i] &&
                dfs(word, pos + 1, node->child[i]))
                return true;
        }
        return false;
    }
}


ğŸ‘‰ é€™ä¸€æ®µå¯ä»¥æ•´æ®µèƒŒèµ·ä¾†

4ï¸âƒ£ è¨˜æ†¶é«”é‡‹æ”¾æ¨¡æ¿ï¼ˆé¢è©¦åŠ åˆ†ï¼‰
void freeTrie(TrieNode* node) {
    if (!node) return;
    for (int i = 0; i < 26; i++)
        freeTrie(node->child[i]);
    delete node;
}

5ï¸âƒ£ æœ€çµ‚ã€é¢è©¦æ¨¡æ¿å®Œæ•´ç‰ˆã€‘ğŸ”¥
#include <iostream>
#include <string>
#include <cstring>
using namespace std;

class WordDictionary {
private:
    struct TrieNode {
        bool isWord;
        TrieNode* child[26];
        TrieNode() : isWord(false) {
            memset(child, 0, sizeof(child));
        }
    };

    TrieNode* root;

    bool dfs(const string& word, int pos, TrieNode* node) {
        if (!node) return false;
        if (pos == word.size())
            return node->isWord;

        char c = word[pos];
        if (c != '.') {
            return dfs(word, pos + 1, node->child[c - 'a']);
        } else {
            for (int i = 0; i < 26; i++) {
                if (node->child[i] &&
                    dfs(word, pos + 1, node->child[i]))
                    return true;
            }
            return false;
        }
    }

    void freeTrie(TrieNode* node) {
        if (!node) return;
        for (int i = 0; i < 26; i++)
            freeTrie(node->child[i]);
        delete node;
    }

public:
    WordDictionary() {
        root = new TrieNode();
    }

    ~WordDictionary() {
        freeTrie(root);
    }

    void addWord(const string& word) {
        TrieNode* node = root;
        for (char c : word) {
            int idx = c - 'a';
            if (!node->child[idx])
                node->child[idx] = new TrieNode();
            node = node->child[idx];
        }
        node->isWord = true;
    }

    bool search(const string& word) {
        return dfs(word, 0, root);
    }
};

6ï¸âƒ£ å¸¸è¦‹é¢è©¦è®Šå½¢æ€éº¼ã€Œç§’æ”¹ã€
ğŸ”¹ æ”¯æ´å¤§å°å¯«
child[52]   // Aâ€“Z + aâ€“z

ğŸ”¹ æ”¯æ´ä»»æ„ ASCII
unordered_map<char, TrieNode*> child;

ğŸ”¹ ä¸ç”¨ recursionï¼ˆé˜² stack overflowï¼‰

â†’ BFS + stackï¼ˆé€²éšé¡Œï¼‰

ğŸ”¹ åŠ ä¸Š prefix æœå°‹
bool startsWith(string prefix)

7ï¸âƒ£ é¢è©¦å®˜è¿½å•æ™‚ä½ å¯ä»¥é€™æ¨£å›ï¼ˆåŠ åˆ†ï¼‰

é€™å€‹è¨­è¨ˆåœ¨æœå°‹åŒ…å« wildcard æ™‚æœ€å£æ™‚é–“æ˜¯ O(26^L)ï¼Œ
ä½†å¯¦éš›ä¸Š Trie çµæ§‹æœƒå¤§é‡å‰ªæï¼Œ
åœ¨å­—å…¸è¦æ¨¡å¤§ã€å­—ä¸²é•·åº¦æœ‰é™æ™‚æ•ˆèƒ½è¡¨ç¾è‰¯å¥½ã€‚

ğŸ¯ çµèª

ä½ ç¾åœ¨é€™ä»½ å·²ç¶“æ˜¯ã€Œå¯ä»¥èƒŒé€²é¢è©¦ã€çš„æ¨¡æ¿ï¼Œ
ä¹‹å¾Œé‡åˆ°ï¼š

Word Search

Wildcard Match

Prefix Dictionary

Autocomplete

Regex-like matching

ğŸ‘‰ ç›´æ¥å¥—é€™ä¸€å¥— Trie + DFS
